<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris - HTML/JS</title>
  <style>
    :root{--cell:30px;--cols:10;--rows:20}
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;display:flex;align-items:flex-start;gap:20px;padding:20px;background: url('telaautismo.png') repeat; background-size: 250px;color:#fff}
    .container{display:flex;gap:20px}
    canvas{background:#000;border:4px solid #fff;image-rendering:pixelated}
    .panel{width:220px}
    h1{margin:0 0 10px;font-size:20px}
    .info{margin-bottom:10px}
    .big{font-size:18px}
    button{display:inline-block;margin-top:8px;padding:8px 12px;border-radius:6px;border:0;background:#222;color:#000;font-weight:bold;cursor:pointer;text-shadow:0 0 12px rgba(255,255,255,0.9),0 0 28px rgba(255,255,255,1),0 0 45px rgba(255,255,255,1);}
    .muted{color:#000;font-size:13px;font-weight:bold;text-shadow:0 0 12px rgba(255,255,255,0.9),0 0 28px rgba(255,255,255,1),0 0 45px rgba(255,255,255,1);}
    .next-canvas{background:#111;border:2px solid #444;width:120px;height:90px}
  .neon{font-size:32px;font-weight:bold;color:#ff1a1a;text-shadow:0 0 15px #ff1a1a,0 0 30px #ff1a1a,0 0 60px #ff1a1a;display:block;margin:40px 0;text-align:right;padding-right:80px;} .right-col{display:flex;align-items:center;justify-content:center;width:120px;}
.neon-vert{font-size:40px;font-weight:bold;color:#000000;text-shadow:0 0 10px #000000,0 0 20px #000000,0 0 30px #000000;writing-mode:vertical-rl;text-orientation:upright;display:flex;flex-direction:column;align-items:center;justify-content:center;animation:neonBlink 1.6s infinite;}
.neon-vert .line{display:block;padding:6px 0;font-size:36px;}
@keyframes neonBlink{0%,45%{opacity:1;text-shadow:0 0 15px #ff1a1a,0 0 30px #ff1a1a,0 0 60px #ff1a1a;}50%{opacity:0.12;text-shadow:none;}95%,100%{opacity:1;text-shadow:0 0 15px #ff1a1a,0 0 30px #ff1a1a,0 0 60px #ff1a1a;}}
</style>
</head>
<body>
  <div class="container">
    <div>
      <canvas id="playfield" width="300" height="600"></canvas>
    </div>

    <aside class="panel">
      <h1 style="font-size:26px;">TETRIS DO PEDRÃO</h1>
      <div class="info"><strong>Score:</strong> <span id="score">0</span></div>
      <div class="info"><strong>Level:</strong> <span id="level">1</span></div>
      <div class="info"><strong>Lines:</strong> <span id="lines">0</span></div>

      <div style="margin-top:12px"><strong>Next</strong></div>
      <canvas id="next" class="next-canvas" width="120" height="90"></canvas>

      <div style="margin-top:12px" class="muted">Controles:</div>
      <div class="muted">← → = mover | ↑ = rotacionar | ↓ = soft drop | Space = hard drop</div>
      <div class="muted">P = pausar | R = reiniciar</div>

      <div style="margin-top:12px"><button id="btnPause">Pausar</button> <button id="btnReset">Reiniciar</button></div>
      <p class="muted" style="margin-top:12px">Se você quiser matar tempo no serviço, abra o jogo</p>
    </aside>

    <aside class="right-col">
      <div class="neon-vert">
      <span class="line">DEMAIS</span>
      <span class="line">PEDRÃO É</span>
    </div>
    </aside>
  </div>

  <script>
    // --- Configuration ---
    const CELL = 30;
    const COLS = 10;
    const ROWS = 20;

    const playCanvas = document.getElementById('playfield');
    const ctx = playCanvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');

    playCanvas.width = CELL * COLS;
    playCanvas.height = CELL * ROWS;

    // Colors
    const COLORS = [null, '#00FF00', '#FF0000', '#00FFFF', '#FFFF00', '#0000FF', '#FFA500', '#800080'];

    // Tetromino shapes using matrices
    const SHAPES = {
      S: [
        [0,0,0,0],
        [0,0,1,1],
        [0,1,1,0],
        [0,0,0,0]
      ],
      Z: [
        [0,0,0,0],
        [0,1,1,0],
        [0,0,1,1],
        [0,0,0,0]
      ],
      I: [
        [0,0,1,0],
        [0,0,1,0],
        [0,0,1,0],
        [0,0,1,0]
      ],
      O: [
        [0,0,0,0],
        [0,0,0,0],
        [0,1,1,0],
        [0,1,1,0]
      ],
      J: [
        [0,1,0,0],
        [0,1,0,0],
        [0,1,1,0],
        [0,0,0,0]
      ],
      L: [
        [0,0,1,0],
        [0,0,1,0],
        [0,1,1,0],
        [0,0,0,0]
      ],
      T: [
        [0,0,0,0],
        [0,1,1,1],
        [0,0,1,0],
        [0,0,0,0]
      ]
    };

    const SHAPE_KEYS = ['S','Z','I','O','J','L','T'];
    const SHAPE_COLOR_INDEX = {'S':1,'Z':2,'I':3,'O':4,'J':5,'L':6,'T':7};

    // Game state
    let grid = createGrid();
    let current = null;
    let next = createPiece(randomShapeKey());
    let dropInterval = 500; // ms
    let lastTime = 0;
    let dropBuffer = 0;
    let score = 0;
    let level = 1;
    let lines = 0;
    let running = true;
    let paused = false;

    // Controls
    const KEY = {LEFT:37, UP:38, RIGHT:39, DOWN:40, SPACE:32, P:80, R:82};

    // Initialize
    function createGrid(){
      const g = [];
      for(let r=0;r<ROWS;r++){
        g.push(new Array(COLS).fill(0));
      }
      return g;
    }

    function randomShapeKey(){
      return SHAPE_KEYS[Math.floor(Math.random()*SHAPE_KEYS.length)];
    }

    function createPiece(key){
      return {
        matrix: SHAPES[key].map(row=>row.slice()),
        x: Math.floor(COLS/2) - 2,
        y: -1,
        key
      };
    }

    function rotate(matrix){
      // rotate 90deg clockwise
      const N = matrix.length;
      const res = Array.from({length:N}, ()=>new Array(N).fill(0));
      for(let r=0;r<N;r++){
        for(let c=0;c<N;c++){
          res[c][N-1-r] = matrix[r][c];
        }
      }
      return res;
    }

    function collide(grid, piece){
      const m = piece.matrix;
      for(let r=0;r<m.length;r++){
        for(let c=0;c<m[r].length;c++){
          if(m[r][c]){
            const x = piece.x + c;
            const y = piece.y + r;
            if(x<0 || x>=COLS || y>=ROWS) return true;
            if(y>=0 && grid[y][x]) return true;
          }
        }
      }
      return false;
    }

    function merge(grid, piece){
      const m = piece.matrix;
      for(let r=0;r<m.length;r++){
        for(let c=0;c<m[r].length;c++){
          if(m[r][c]){
            const x = piece.x + c;
            const y = piece.y + r;
            if(y>=0) grid[y][x] = SHAPE_COLOR_INDEX[piece.key];
          }
        }
      }
    }

    function sweep(){
      let rowCount = 0;
      outer: for(let r=ROWS-1;r>=0;r--){
        for(let c=0;c<COLS;c++){
          if(!grid[r][c]){
            continue outer;
          }
        }
        // row full
        rowCount++;
        grid.splice(r,1);
        grid.unshift(new Array(COLS).fill(0));
        r++; // recheck same index after splice
      }
      if(rowCount>0){
        // scoring similar to classic Tetris
        const pointsMap = {1:40,2:100,3:300,4:1200};
        score += (pointsMap[rowCount] || (rowCount*100)) * level;
        lines += rowCount;
        level = Math.floor(lines/10) + 1;
        // increase speed
        dropInterval = Math.max(50, 500 - (level-1)*30);
        updateStats();
      }
    }

    function updateStats(){
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('lines').textContent = lines;
    }

    function reset(){
      grid = createGrid();
      current = null;
      next = createPiece(randomShapeKey());
      score = 0; level = 1; lines = 0;
      dropInterval = 500; updateStats();
      running = true; paused = false;
    }

    // Input handlers
    window.addEventListener('keydown', e=>{
      if(e.keyCode===KEY.P){ togglePause(); return; }
      if(e.keyCode===KEY.R){ reset(); return; }
      if(paused || !running) return;

      if(e.keyCode===KEY.LEFT){
        current.x--;
        if(collide(grid,current)) current.x++;
      } else if(e.keyCode===KEY.RIGHT){
        current.x++;
        if(collide(grid,current)) current.x--;
      } else if(e.keyCode===KEY.UP){
        const old = current.matrix;
        current.matrix = rotate(current.matrix);
        // wall kicks simple: try left/right
        if(collide(grid,current)){
          current.x++;
          if(collide(grid,current)){
            current.x-=2;
            if(collide(grid,current)){
              current.x+=1;
              current.matrix = old; // revert
            }
          }
        }
      } else if(e.keyCode===KEY.DOWN){
        // soft drop
        current.y++;
        if(collide(grid,current)) current.y--;
      } else if(e.keyCode===KEY.SPACE){
        // hard drop
        while(!collide(grid,current)){
          current.y++;
        }
        current.y--;
        lockPiece();
      }
      draw();
    });

    document.getElementById('btnPause').addEventListener('click',togglePause);
    document.getElementById('btnReset').addEventListener('click',reset);

    function togglePause(){
      paused = !paused;
      document.getElementById('btnPause').textContent = paused? 'Retomar' : 'Pausar';
      if(!paused) lastTime = performance.now();
      draw();
    }

    function spawn(){
      current = next;
      next = createPiece(randomShapeKey());
      if(collide(grid,current)){
        // game over
        running = false;
      }
    }

    function lockPiece(){
      merge(grid,current);
      sweep();
      spawn();
    }

    function drawCell(ctx,x,y,idx){
      if(!idx) return;
      ctx.fillStyle = COLORS[idx];
      ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 1;
      ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
    }

    function draw(){
      // playfield
      ctx.clearRect(0,0,playCanvas.width,playCanvas.height);
      // background grid
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,playCanvas.width,playCanvas.height);

      // draw placed blocks
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          drawCell(ctx,c,r,grid[r][c]);
        }
      }

      // draw current
      if(current){
        const m = current.matrix;
        for(let r=0;r<m.length;r++){
          for(let c=0;c<m[r].length;c++){
            if(m[r][c]){
              const x = current.x + c;
              const y = current.y + r;
              if(y>=0) drawCell(ctx,x,y,SHAPE_COLOR_INDEX[current.key]);
            }
          }
        }
      }

      // draw next
      nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
      nctx.fillStyle='#111'; nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
      const nm = next.matrix;
      const offsetX = 1; const offsetY = 0;
      for(let r=0;r<nm.length;r++){
        for(let c=0;c<nm[r].length;c++){
          if(nm[r][c]){
            const x = c + offsetX;
            const y = r + offsetY;
            nctx.fillStyle = COLORS[SHAPE_COLOR_INDEX[next.key]];
            nctx.fillRect(x*(CELL/2), y*(CELL/2), CELL/2, CELL/2);
            nctx.strokeStyle = '#111'; nctx.strokeRect(x*(CELL/2), y*(CELL/2), CELL/2, CELL/2);
          }
        }
      }

      // overlay text if not running
      if(!running){
        ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,playCanvas.height/2-40,playCanvas.width,80);
        ctx.fillStyle='#fff'; ctx.font='28px system-ui'; ctx.textAlign='center';
        ctx.fillText('YOU LOST', playCanvas.width/2, playCanvas.height/2+8);
      }

      if(paused){
        ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,playCanvas.height/2-40,playCanvas.width,80);
        ctx.fillStyle='#fff'; ctx.font='24px system-ui'; ctx.textAlign='center';
        ctx.fillText('PAUSED', playCanvas.width/2, playCanvas.height/2+8);
      }
    }

    function update(time=0){
      if(!lastTime) lastTime = time;
      const delta = time - lastTime;
      if(!paused && running){
        dropBuffer += delta;
        if(!current) spawn();
        if(dropBuffer > dropInterval){
          current.y++;
          if(collide(grid,current)){
            current.y--;
            lockPiece();
          }
          dropBuffer = 0;
        }
      }
      draw();
      lastTime = time;
      requestAnimationFrame(update);
    }

    // Start game
    reset();
    update();
  </script>
</body>
</html>
